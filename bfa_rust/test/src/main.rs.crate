struct main::List
{
  head : main::Link,
}

enum main::Link
  =
|  Empty()
|  More(alloc::boxed::Box<main::Node>[core::marker::Sized<alloc::alloc::Global>])

struct main::Node
{
  elem : i32,
  next : main::Link,
}

struct alloc::alloc::Global{}

enum core::option::Option<T>
where
  [TraitClause@0]: core::marker::Sized<T>,
  =
|  None()
|  Some(T)

trait core::marker::Sized<Self>
{
  // Required methods
  // Provided methods
}

fn main::{main::List}::new() -> main::List
{
  v@0 : main::List;
  v@1 : main::Link;

  block@0 {
    v@1 := main::Link::main::Link::Empty ();
    v@0 := main::List { head = move v@1; };
    drop v@1;
    storage_dead v@1;
    return;
  }
}

fn main::{main::List}::push<0>(self^1 : &0 mut (main::List), elem^2 : i32)
{
  v@0 : ();
  self^1 : &'_ mut (main::List);
  elem^2 : i32;
  new_node^3 : alloc::boxed::Box<main::Node>[core::marker::Sized<alloc::alloc::Global>];
  v@4 : main::Node;
  v@5 : i32;
  v@6 : main::Link;
  v@7 : &'_ mut (main::Link);
  v@8 : &'_ mut (main::Link);
  v@9 : main::Link;
  v@10 : main::Link;
  v@11 : alloc::boxed::Box<main::Node>[core::marker::Sized<alloc::alloc::Global>];
  v@12 : ();

  block@0 {
    v@5 := copy elem^2;
    v@8 := &mut (*(self^1)).head;
    v@7 := &two-phase *(v@8);
    v@9 := main::Link::main::Link::Empty ();
    v@6 := move core::mem::replace<'_, main::Link>[core::marker::Sized<main::Link>](move v@7, move v@9);
    storage_dead v@9;
    storage_dead v@7;
    v@4 := main::Node { elem = move v@5; next = move v@6; };
    drop v@6;
    storage_dead v@6;
    storage_dead v@5;
    new_node^3 := move alloc::boxed::Box::new<main::Node>[core::marker::Sized<main::Node>](move v@4);
    storage_dead v@4;
    fake_read new_node^3;
    storage_dead v@8;
    v@11 := move new_node^3;
    v@10 := main::Link::main::Link::More (move v@11);
    drop v@11;
    storage_dead v@11;
    drop (*(self^1)).head;
    (*(self^1)).head := move v@10;
    drop v@10;
    storage_dead v@10;
    v@12 := ();
    v@0 := move v@12;
    drop new_node^3;
    storage_dead new_node^3;
    v@0 := ();
    return;
  }
}

fn main::{main::List}::pop<0>(self^1 : &0 mut (main::List)) -> core::option::Option<i32>[core::marker::Sized<i32>]
{
  v@0 : core::option::Option<i32>[core::marker::Sized<i32>];
  self^1 : &'_ mut (main::List);
  v@2 : main::Link;
  v@3 : &'_ mut (main::Link);
  v@4 : &'_ mut (main::Link);
  v@5 : main::Link;
  v@6 : isize;
  node^7 : alloc::boxed::Box<main::Node>[core::marker::Sized<alloc::alloc::Global>];
  v@8 : main::Link;
  v@9 : i32;

  block@0 {
    v@4 := &mut (*(self^1)).head;
    v@3 := &two-phase *(v@4);
    v@5 := main::Link::main::Link::Empty ();
    v@2 := move core::mem::replace<'_, main::Link>[core::marker::Sized<main::Link>](move v@3, move v@5);
    storage_dead v@5;
    storage_dead v@3;
    fake_read v@2;
    v@6 := discriminant(v@2);
    switch move v@6    [0: isize -> block@1; 1: isize -> block@2; _ -> block@3];
  }

  block@1 {
    v@0 := core::option::Option::core::option::Option::None ();
    goto block@4;
  }

  block@2 {
    node^7 := move (v@2 as main::Link::More).0;
    v@8 := move (*(node^7)).next;
    drop (*(self^1)).head;
    (*(self^1)).head := move v@8;
    drop v@8;
    storage_dead v@8;
    v@9 := copy (*(node^7)).elem;
    v@0 := core::option::Option::core::option::Option::Some (move v@9);
    storage_dead v@9;
    drop node^7;
    storage_dead node^7;
    goto block@4;
  }

  block@3 {
    fake_read v@2;
    panic;
  }

  block@4 {
    drop v@2;
    storage_dead v@4;
    storage_dead v@2;
    return;
  }
}

fn main::main()
{
  v@0 : ();
  list^1 : main::List;
  v@2 : ();
  v@3 : &'_ mut (main::List);
  v@4 : ();
  v@5 : &'_ mut (main::List);
  _r^6 : core::option::Option<i32>[core::marker::Sized<i32>];
  v@7 : &'_ mut (main::List);
  v@8 : ();

  block@0 {
    list^1 := move main::{main::List}::new();
    fake_read list^1;
    v@3 := &two-phase list^1;
    v@2 := move main::{main::List}::push<'_>(move v@3, (1: i32 : i32));
    storage_dead v@3;
    storage_dead v@2;
    v@5 := &two-phase list^1;
    v@4 := move main::{main::List}::push<'_>(move v@5, (2: i32 : i32));
    storage_dead v@5;
    storage_dead v@4;
    v@7 := &two-phase list^1;
    _r^6 := move main::{main::List}::pop<'_>(move v@7);
    storage_dead v@7;
    fake_read _r^6;
    v@8 := ();
    v@0 := move v@8;
    storage_dead _r^6;
    drop list^1;
    storage_dead list^1;
    v@0 := ();
    return;
  }
}

fn core::mem::replace<0, T>(dest^1 : &0 mut (T), src^2 : T) -> T
where
  [TraitClause@0]: core::marker::Sized<T>,
{
  result^0 : T;
  dest^1 : &'_ mut (T);
  src^2 : T;

  block@0 {
    result^0 := copy *(dest^1);
    *(dest^1) := copy src^2;
    return;
  }
}